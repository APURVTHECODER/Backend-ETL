name: Backend CI/CD

on:
  push:
    branches: [ "*" ] # Trigger deployment only on pushes to main
  pull_request:
    branches: [ "*" ] # Trigger tests on PRs to main
# Define environment variables using GitHub Secrets
# Note: Non-secret values could be hardcoded for better readability, but using secrets works.
env:
  # --- CORRECTED ENV VARS ---
  GCP_PROJECT_ID: crafty-tracker-457215-g6
  GAR_LOCATION: us-central1          # Your GAR Location
  APP_REPO_NAME: app-images           # Your GAR Repo Name
  GKE_CLUSTER_NAME: cluster-1     # Your GKE Cluster Name
  GKE_ZONE: us-central1-a           # Your GKE Zone
  GCP_WORKLOAD_IDENTITY_PROVIDER: 'projects/1076741205751/locations/global/workloadIdentityPools/github-actions-pool/providers/github-provider' # Your WIF Provider
  GCP_SERVICE_ACCOUNT: 'github-actions-deployer@crafty-tracker-457215-g6.iam.gserviceaccount.com' # Your SA Email

jobs:
  test:
    name: Run Backend Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python 3.10
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install Dependencies
        run: pip install -r backend/requirements.txt # Path relative to repo root

      - name: Run Tests # Replace with your actual test command
        # Example: run: pytest backend/tests/ -v
        run: echo "Running backend tests... (Update this step with your test command)"

  build-and-push:
    name: Build and Push Backend Image
    needs: test # Only run if tests pass
    runs-on: ubuntu-latest
    # Only run on actual push to the main branch
    permissions:
      contents: 'read'
      id-token: 'write' # Required for Workload Identity Federation

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Authenticate to Google Cloud using WIF
      - name: Authenticate to Google Cloud
        id: auth
        uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: ${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.GCP_SERVICE_ACCOUNT }}

      # Set up gcloud CLI
      - name: Set up Cloud SDK
        uses: 'google-github-actions/setup-gcloud@v2'

      # Configure Docker to use the gcloud command-line tool as a credential helper
      - name: Configure Docker Credential Helper
        run: gcloud auth configure-docker ${{ env.GAR_LOCATION }}-docker.pkg.dev --quiet

      # Set up Docker Buildx for optimized builds
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Build and push Backend image
      - name: Build and Push Backend
        id: build_backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend # Build context is the backend directory
          push: true
          # Construct the image tag using GAR location, project ID, repo name, component name, and commit SHA
          tags: ${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.APP_REPO_NAME }}/backend:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # --- Add separate build steps for frontend and worker if needed in this repo ---
      # - name: Build and Push Frontend
      #   uses: docker/build-push-action@v5
      #   with:
      #     context: ./frontend # If frontend code is also here
      #     push: true
      #     tags: ${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.APP_REPO_NAME }}/frontend:${{ github.sha }}
      #     cache-from: type=gha
      #     cache-to: type=gha,mode=max
      #
      # - name: Build and Push Worker
      #   uses: docker/build-push-action@v5
      #   with:
      #     context: ./worker # If worker code is also here
      #     push: true
      #     tags: ${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.APP_REPO_NAME }}/worker:${{ github.sha }}
      #     cache-from: type=gha
      #     cache-to: type=gha,mode=max

  deploy:
    name: Deploy to GKE
    needs: build-and-push # Run only after successful build
    runs-on: ubuntu-latest
    # Only run on actual push to the main branch
    permissions:
      contents: 'read' # To read k8s files
      id-token: 'write' # To authenticate to GCP via WIF

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Authenticate to Google Cloud using WIF
      - name: Authenticate to GCP
        id: auth
        uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: ${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.GCP_SERVICE_ACCOUNT }}

      # Set up gcloud & kubectl
      - name: Set up Cloud SDK & Kubectl
        uses: 'google-github-actions/setup-gcloud@v2'
      - run: gcloud components install gke-gcloud-auth-plugin --quiet

      # Get GKE cluster credentials
      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials \
            "${{ env.GKE_CLUSTER_NAME }}" \
            --zone "${{ env.GKE_ZONE }}" \
            --project "${{ env.GCP_PROJECT_ID }}"

      # Create/Update Kubernetes Secret object with runtime secrets from GitHub Secrets
      # Step: Create/Update Kubernetes 'app-secrets' Secret from GitHub Secrets
# In Backend-ETL/.github/workflows/ci-cd.yaml (deploy job)

      # Corrected Step: Create/Update Kubernetes 'app-secrets' Secret (Passing Base64 As Is)
      # Corrected Step: Create/Update Kubernetes App Secrets (Using Env Vars for kubectl)
      - name: Create/Update Kubernetes App Secrets
        env:
          # Map ALL relevant GitHub Secrets to workflow env vars for this step
          # Base64 Encoded Secrets
          SECRET_FIREBASE_B64: ${{ secrets.FIREBASE_ADMIN_SDK_KEY_BASE64 }}
          SECRET_GAC_B64: ${{ secrets.GOOGLE_APPLICATION_CREDENTIALS }}
          # Plain Text Secrets
          SECRET_GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          SECRET_ALLOWED_ORIGINS: ${{ secrets.ALLOWED_ORIGINS }}
          SECRET_PUBSUB_SUBSCRIPTION: ${{ secrets.PUBSUB_SUBSCRIPTION }}
          SECRET_WORKER_GEMINI_TIMEOUT: ${{ secrets.WORKER_GEMINI_TIMEOUT }}
          # SECRET_DATABASE_URL: ${{ secrets.DATABASE_URL }} # Example if needed
        run: |
          echo "Preparing Kubernetes secret 'app-secrets'..."

          # --- Validate required secrets are not empty ---
          if [ -z "$SECRET_FIREBASE_B64" ]; then echo "Error: FIREBASE_ADMIN_SDK_KEY_BASE64 secret is empty!"; exit 1; fi
          # Add checks for other critical secrets if necessary
          if [ -z "$SECRET_GEMINI_API_KEY" ]; then echo "Warning: GEMINI_API_KEY secret is empty!"; fi
          # ... add other warnings if needed ...

          # --- Build the --from-literal arguments ---
          # Start with an empty array or string
          literal_args=""

          # Add Base64 secrets
          literal_args+=" --from-literal=firebase.key.base64=$SECRET_FIREBASE_B64"
          if [ -n "$SECRET_GAC_B64" ]; then
            literal_args+=" --from-literal=google.creds.base64=$SECRET_GAC_B64"
          fi

          # Add Plain text secrets
          literal_args+=" --from-literal=gemini.api.key=$SECRET_GEMINI_API_KEY"
          literal_args+=" --from-literal=allowed.origins=$SECRET_ALLOWED_ORIGINS"
          literal_args+=" --from-literal=pubsub.subscription=$SECRET_PUBSUB_SUBSCRIPTION"
          literal_args+=" --from-literal=worker.gemini.timeout=$SECRET_WORKER_GEMINI_TIMEOUT"
          # if [ -n "$SECRET_DB_URL" ]; then literal_args+=" --from-literal=database.url=$SECRET_DB_URL"; fi

          echo "Applying Kubernetes secret 'app-secrets' using arguments..."
          # --- Execute kubectl create secret directly, passing secrets via ENV ---
          # The shell will substitute the env vars in literal_args before executing kubectl
          kubectl create secret generic app-secrets \
            $literal_args \
            --dry-run=client -o yaml | kubectl apply -f -

          if [ $? -ne 0 ]; then echo "Error: Failed applying Kubernetes secret 'app-secrets'"; exit 1; fi

          echo "✅ Successfully applied/updated Kubernetes secret: app-secrets"




      # Create/Update Kubernetes ConfigMap with non-secret config from GitHub Secrets
      - name: Create/Update Kubernetes ConfigMap
        env:
          # Map GitHub Secrets to temporary env vars for the script
          CONFIG_GCS_BUCKET_NAME: ${{ secrets.GCS_BUCKET }}
          CONFIG_FEEDBACK_BUCKET: ${{ secrets.FEEDBACK_BUCKET }}
          CONFIG_PUBSUB_TOPIC_NAME: ${{ secrets.PUBSUB_TOPIC }}
          # CONFIG_ALLOWED_ORIGINS: ${{ secrets.ALLOWED_ORIGINS }} # Example
        run: |
          # Create ConfigMap definition dynamically
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: app-config
          data:
            log.level: "INFO" # Example static value
            gcs.bucket: "$CONFIG_GCS_BUCKET_NAME"
            gcs.bucketfeedback: "$CONFIG_FEEDBACK_BUCKET"
            pubsub.topic: "$CONFIG_PUBSUB_TOPIC_NAME"
            # allowed.origins: "$CONFIG_ALLOWED_ORIGINS" # Example
            # Add other non-sensitive config key-value pairs here
          EOF
          echo "Applied/Updated Kubernetes ConfigMap: app-config"

      # Template Kubernetes Deployment files using envsubst
      - name: Template Kubernetes Deployments
        run: |
          # Export variables needed for substitution
          # IMAGE_TAG uses the commit SHA from the trigger event
          export IMAGE_TAG=${{ github.sha }}
          # Export other variables needed in the YAML templates if any (e.g., project ID, location)
          # These are pulled from the workflow's top-level env block
          export GAR_LOCATION=${{ env.GAR_LOCATION }}
          export GCP_PROJECT_ID=${{ env.GCP_PROJECT_ID }}
          export APP_REPO_NAME=${{ env.APP_REPO_NAME }}

          echo "Templating backend deployment (Image Tag: $IMAGE_TAG)..."
          envsubst < backend/k8s/backend-deployment.yaml > backend/k8s/tmp-backend-deployment.yaml

          echo "Templating frontend deployment (Image Tag: $IMAGE_TAG)..."
          # Use the SAME image tag for frontend if built in the same workflow,
          # otherwise, fetch the latest tag or use a fixed tag if built separately
          envsubst < backend/k8s/frontend-deployment.yaml  > backend/k8s/tmp-frontend-deployment.yaml

          echo "Templating worker deployment (Image Tag: $IMAGE_TAG)..."
          # Use the SAME image tag for worker if built in the same workflow,
          # otherwise, fetch the latest tag or use a fixed tag if built separately
          envsubst < backend/k8s/worker-deployment.yaml    > backend/k8s/tmp-worker-deployment.yaml

      # Apply ALL Kubernetes resources from the backend/k8s directory
      # Applies static resources first, then templated ones
      - name: Apply Kubernetes Resources
        run: |
          echo "Applying ManagedCertificate, static services, and ingress..."
          kubectl apply -f backend/k8s/backend-service.yaml
          kubectl apply -f backend/k8s/frontend-service.yaml # Assuming you have a frontend
          kubectl apply -f backend/k8s/ingress.yaml
          # ConfigMap and Secrets were applied individually above
          echo "Applying templated deployments..."
          kubectl apply -f backend/k8s/tmp-backend-deployment.yaml
          kubectl apply -f backend/k8s/tmp-frontend-deployment.yaml # Assuming you have a frontend
          kubectl apply -f backend/k8s/tmp-worker-deployment.yaml   # Assuming you have a worker

      # Wait for deployment rollouts to complete
      - name: Wait for Deployments Rollout
        run: |
          echo "Waiting for backend rollout..."
          kubectl rollout status deployment/backend-deployment --timeout=5m
          echo "Waiting for frontend rollout..." # Comment out if no frontend
          kubectl rollout status deployment/frontend-deployment --timeout=5m
          echo "Waiting for worker rollout..."   # Comment out if no worker
          kubectl rollout status deployment/worker-deployment --timeout=5m

      # Get the Ingress IP (Load Balancer IP)
      - name: Get Ingress IP
        id: ingress_ip
        run: |
           echo "Waiting for Ingress IP address..."
           for i in {1..30}; do # Retry for 5 minutes (30 * 10 seconds)
             IP=$(kubectl get ingress app-ingress -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null) || IP=""
             if [ -n "$IP" ]; then
               echo "Ingress IP found: $IP"
               echo "ingress_ip=$IP" >> $GITHUB_OUTPUT
               exit 0
             fi
             echo "Attempt $i: Ingress IP not available yet, waiting 10s..."
             sleep 10
           done
           echo "Error: Ingress IP address not found after 5 minutes."
           exit 1

      # Output the URL for easy access
      - name: Output Deployed URL
        run: echo "✅ Application should be accessible (after DNS propagation if applicable) at http://${{ steps.ingress_ip.outputs.ingress_ip }}"
